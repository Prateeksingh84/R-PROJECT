# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dthvHez7j0wVK6226Y6KnF3nUNx1KknC
"""

!pip install tensorflow==2.9.1

import matplotlib.pyplot as plt
import numpy as np
import os
import tensorflow as tf
import random
import cv2
from tqdm import tqdm
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, Dropout
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

no_tb_data = "/content/TB DATASET/NORMAL"
tb_data = "/content/TB DATASET/TB LUNGS"

_yes = []
for image in tqdm(os.listdir(tb_data)):
    image_path = os.path.join(tb_data, image)
    img = cv2.imread(image_path)
    img = cv2.resize(img, (224, 224))
    _yes.append(img) # Changed X_yes to _yes

_yes = []
for image in tqdm(os.listdir(tb_data)):
    image_path = os.path.join(tb_data, image)
    img = cv2.imread(image_path)
    img = cv2.resize(img, (224, 224))
    _yes.append(img) # changed X_yes to _yes
#Also change X_yes to _yes in next cell.
x_yes = np.array(_yes) # changed X_yes to _yes

datagen = ImageDataGenerator(rotation_range=20, width_shift_range=0.2, height_shift_range=0.2,
                             horizontal_flip=True, fill_mode='nearest')

aug_images = []
for image in tqdm(x_yes):
    image = np.expand_dims(image, axis=0)
    i = 0
    for batch in datagen.flow(image, batch_size=1):
        aug_images.append(batch[0])
        i += 1
        if i >= 5:
            break

X_no = []
for image in tqdm(os.listdir(no_tb_data)):
    image_path = os.path.join(no_tb_data, image)
    img = cv2.imread(image_path)
    img = cv2.resize(img, (224, 224))
    X_no.append(img)

TB_no = []
for image in tqdm(X_no):
    TB_no.append([image, 0])

# ipython-input-17-2f6b2a6935cd
datagen = ImageDataGenerator(rotation_range=20, width_shift_range=0.2, height_shift_range=0.2,
                             horizontal_flip=True, fill_mode='nearest')

# Change aug_images to TB_yes
TB_yes = []
for image in tqdm(x_yes):
    image = np.expand_dims(image, axis=0)
    i = 0
    for batch in datagen.flow(image, batch_size=1):
        TB_yes.append(batch[0])  # Append to TB_yes
        i += 1
        if i >= 5:
            break

# After applying augmentation, create a list of [image, label] pairs for TB_yes
TB_yes = [[image, 1] for image in TB_yes]  # Assuming 1 is the label for TB positive cases

# Import necessary libraries
import random

# ... (Your previous code for generating TB_yes and TB_no) ...

# Combine TB_yes and TB_no into a single dataset called 'data'
data = TB_yes + TB_no

# Now you can shuffle the data
random.shuffle(data)

X = []
y = []
for i, j in tqdm(data):
    X.append(i)
    y.append(j)

x = np.array(X)
y = np.array(y)

x_train = x[:5500]
y_train = y[:5500]

x_test = x[5500:7000]
y_test = y[5500:7000]

model = Sequential()

model.add(Conv2D(100,(3, 3), activation = "relu", input_shape = (224, 224, 3)))
model.add(MaxPooling2D(2, 2))

model.add(Conv2D(100,(3, 3), activation = "relu"))
model.add(MaxPooling2D(2, 2))

model.add(Conv2D(64,(3, 3), activation = "relu"))
#model.add(MaxPooling2D(2, 2))

model.add(Conv2D(64,(3, 3), activation = "relu"))
model.add(MaxPooling2D(2, 2))

model.add(Flatten())
model.add(Dense(64, activation = "relu"))
model.add(Dropout(.2))
#model.add(Dense(32, activation = "relu"))
model.add(Dropout(.3))
model.add(Dense(32, activation = "relu"))
model.add(Dense(1, activation = 'sigmoid'))

model.compile(optimizer="adam", loss='binary_crossentropy', metrics=['accuracy'])

history = model.fit(x_train, y_train, validation_split= .2, epochs = 5)

plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()


plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.tight_layout()
plt.show()

import tensorflow as tf # Import tensorflow

# ... (Your existing model code) ...

model.compile(optimizer="adam", loss='binary_crossentropy', metrics=['accuracy'], run_eagerly=True) # Added run_eagerly=True

# ... (Rest of your code) ...

import numpy as np

# Check if y_test is empty and handle the case
if y_test.size == 0:
    print("Warning: y_test is empty. Evaluation cannot be performed.")
else:
    # Proceed with model evaluation if y_test is not empty
    loss, accuracy = model.evaluate(x_test, y_test, verbose=0)
    print(f"Test Loss: {loss:.4f}")
    print(f"Test Accuracy: {accuracy:.4f}")

import tensorflow as tf
from sklearn.metrics import confusion_matrix

# ... (Your existing model code and training) ...

# Check if x_test is empty
if x_test.size == 0:
    print("Error: x_test is empty. Please ensure you have data in your test set.")
else:
    # Generate predictions using your trained model
    y_pred = model.predict(x_test)

    # Convert probabilities to class labels (0 or 1)
    y_pred = [1 if prob >= 0.5 else 0 for prob in y_pred]  # Assuming binary classification

    # Calculate the confusion matrix
    cm = confusion_matrix(y_test, y_pred)

# ... (Rest of your code) ...

import tensorflow as tf
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt

# Ensure that x_test is not empty and has the correct dimensions
if x_test.size == 0 or x_test.ndim < 2:
    print("Error: x_test is empty or has incorrect dimensions. Please ensure you have data in your test set.")
else:
    # Generate predictions using your trained model
    y_pred_probs = model.predict(x_test)

    # Convert probabilities to class labels (0 or 1)
    y_pred = [1 if prob >= 0.5 else 0 for prob in y_pred_probs.flatten()]  # Ensure y_pred_probs is 1D

    # Calculate the confusion matrix
    cm = confusion_matrix(y_test, y_pred)

    # Display the confusion matrix
    plt.figure(figsize=(12, 10))
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=['Class 0', 'Class 1'])
    disp.plot(cmap=plt.cm.Blues)
    plt.xticks(rotation=90)
    plt.show()

import numpy as np

# Check if y_test is empty and handle the case
if y_test.size == 0:
    print("Warning: y_test is empty. Evaluation cannot be performed.")
else:
    # Proceed with model evaluation if y_test is not empty
    loss, accuracy = model.evaluate(x_test, y_test, verbose=0)
    print(f"Test Loss: {loss:.4f}")
    print(f"Test Accuracy: {accuracy:.4f}")

model.evaluate(x_test, y_test)